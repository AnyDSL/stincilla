// Common
// pipe support
type pipe = channel;

// --------------------- accessor: mapping dependent functions ----------------
fn @copy_img(src: Img, dst: Img) -> () {
    copy_real_img(src, dst);
}

// new
// --------------------- memory copy functions --------------------------------
fn @copy_real_img(src: Img, dst: Img) -> () {
    if src.virtual == false {
        copy(src.buf, dst.buf)
    }
}

fn @get_device_copy(img: Img) -> Img {
    if img.virtual == false {
        let acc = accelerator(device_id);
        let img_dev = alloc_img(img, acc.alloc);
        copy_real_img(img, img_dev);
        img_dev
    } else {
        img
    }
}

fn @get_aocl_sync(img: Img) -> fn() -> () {
    if img.virtual == false {
      let acc = accelerator(device_id);
      acc.sync
    } else {
        ||()
    }
}

fn @get_host_copy(img_dev: Img, img: Img) -> () {
    if img_dev.virtual == false {
        copy_real_img(img_dev, img)
    } 
}

fn @release_device_copy(img: Img) -> () {
    if img.virtual == false {
        release(img.buf)
    }
}

// ---------------------------- streaming --------------------------------------
fn @get_stream(img: Img) -> stream_in {
    let pFactor = get_vector_length();
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        get_stream_from_global_img(real_img, pFactor)
    } else {
        channel_to_stream_in(img, pFactor)
    }
}

fn @set_stream(img: Img) -> stream_out {
    let pFactor = get_vector_length();
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        set_stream_from_global_img(real_img, pFactor)
    } else {
        channel_to_stream_out(img, pFactor)
    }
}

fn @channel_to_stream_in(img: Img, pFactor: int) -> stream_in {
    match pFactor {
         1 => channel_to_stream_in_vec1 (img),
         2 => channel_to_stream_in_vec2 (img),
         4 => channel_to_stream_in_vec4 (img),
         8 => channel_to_stream_in_vec8 (img),
        16 => channel_to_stream_in_vec16(img),
        32 => channel_to_stream_in_vec32(img),
         _ => undef[stream_in]()
    }
}

fn @channel_to_stream_out(img: Img, pFactor: int) -> stream_out {
    match pFactor {
         1 => channel_to_stream_out_vec1 (img),
         2 => channel_to_stream_out_vec2 (img),
         4 => channel_to_stream_out_vec4 (img),
         8 => channel_to_stream_out_vec8 (img),
        16 => channel_to_stream_out_vec16(img),
        32 => channel_to_stream_out_vec32(img),
         _ => undef[stream_out]()
    }
}

fn @channel_to_stream_out_vec1(img: Img) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { write_channel(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    img_to_stream_out(img, 1, update, write)
}

fn @channel_to_stream_out_vec2(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { write_channel2(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 2, update, write)
}

fn @channel_to_stream_out_vec4(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { write_channel4(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 4, update, write)
}

fn @channel_to_stream_out_vec8(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { write_channel8(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 8, update, write)
}

fn @channel_to_stream_out_vec16(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { write_channel16(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 16, update, write)
}

fn @channel_to_stream_out_vec32(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { write_channel32(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 32, update, write)
}

fn @channel_to_stream_in_vec1(img: Img) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = read_channel(img.fifo); }
    fn @read(idx: int) -> pixel_t { value }
    img_to_stream_in(img, 1, update, read)
}

fn @channel_to_stream_in_vec2(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { value = read_channel2(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 2, update, read)
}

fn @channel_to_stream_in_vec4(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { value = read_channel4(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 4, update, read)
}

fn @channel_to_stream_in_vec8(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { value = read_channel8(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 8, update, read)
}

fn @channel_to_stream_in_vec16(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { value = read_channel16(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 16, update, read)
}

fn @channel_to_stream_in_vec32(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { value = read_channel32(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 32, update, read)
}

// global
fn @get_stream_from_global_img(img: Img, pFactor: int) -> stream_in {
    match pFactor {
         1 => get_global_stream_vec1 (img),
         2 => get_global_stream_vec2 (img),
         4 => get_global_stream_vec4 (img),
         8 => get_global_stream_vec8 (img),
        16 => get_global_stream_vec16(img),
        32 => get_global_stream_vec32(img),
         _ => undef[stream_in]()
    }
}

fn @set_stream_from_global_img(img: Img, pFactor: int) -> stream_out {
    match pFactor {
         1 => set_global_stream_vec1 (img),
         2 => set_global_stream_vec2 (img),
         4 => set_global_stream_vec4 (img),
         8 => set_global_stream_vec8 (img),
        16 => set_global_stream_vec16(img),
        32 => set_global_stream_vec32(img),
         _ => undef[stream_out]()
    }
}


fn @get_global_stream_vec1(img: Img) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = bitcast[&[1][pixel_t]](img.buf.data)(idx); }
    fn @read(idx: int) -> pixel_t { value }
    img_to_stream_in(img, 1, update, read)
}

fn @get_global_stream_vec2(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 2, update, read)
}

fn @get_global_stream_vec4(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 4, update, read)
}

fn @get_global_stream_vec8(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 8, update, read)
}

fn @get_global_stream_vec16(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 16, update, read)
}

fn @get_global_stream_vec32(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 32, update, read)
}

fn @set_global_stream_vec1(img: Img) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    img_to_stream_out(img, 1, update, write)
}

fn @set_global_stream_vec2(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 2, update, write)
}

fn @set_global_stream_vec4(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 4, update, write)
}

fn @set_global_stream_vec8(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 8, update, write)
}

fn @set_global_stream_vec16(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 16, update, write)
}

fn @set_global_stream_vec32(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 32, update, write)
}

//  ------------------- Stencil Processing ----------------------
fn @iteration(math: Intrinsics, out: Img, imgs: ImgList, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let ext = get_max_ext(imgs);
    let out_dev = get_device_copy(out);
    let imgs_gpu = for img, ext in img_list_map(imgs) {
        get_device_copy(img)
    };

    for benchmark_fpga( get_aocl_sync(out) ) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            //FetchAndCalc, CalcAndPack, FetchAndCalc_nobh, CalcAndPack_nobh
            let coarsening_fun = coarsening_policy;

            // TODO: stream list
            let in_s  = get_stream(imgs_gpu.get(0));
            let out_s = set_stream(out_dev);
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, ext, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point(math: Intrinsics, out: Img, arr: Img, body: fn(Intrinsics, i32, i32, Acc, pixel_t) -> ()) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga( get_aocl_sync(out) ) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = set_stream(out_dev);
            let in_s = get_stream(arr_dev);

            iter_point_body(math, pFactor, out_s, in_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point2(math: Intrinsics, out: Img, arr0: Img, arr1: Img, body: fn(Intrinsics, i32, i32, Acc, pixel_t, pixel_t) -> ()) -> () {
    let acc = accelerator(device_id);
    let arr0_dev = get_device_copy(arr0);
    let arr1_dev = get_device_copy(arr1);
    let out_dev = get_device_copy(out);

    for benchmark_fpga( get_aocl_sync(out) ) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = set_stream(out_dev);
            let in0_s = get_stream(arr0_dev);
            let in1_s = get_stream(arr1_dev);

            iter_point2_body(math, pFactor, out_s, in0_s, in1_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point3(math: Intrinsics, out: Img, arr0: Img, arr1: Img, arr2: Img, body: fn(Intrinsics, i32, i32, Acc, pixel_t, pixel_t, pixel_t) -> ()) -> () {
    let acc = accelerator(device_id);
    let arr0_dev = get_device_copy(arr0);
    let arr1_dev = get_device_copy(arr1);
    let arr2_dev = get_device_copy(arr2);
    let out_dev = get_device_copy(out);

    for benchmark_fpga( get_aocl_sync(out) ) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = set_stream(out_dev);
            let in0_s = get_stream(arr0_dev);
            let in1_s = get_stream(arr1_dev);
            let in2_s = get_stream(arr2_dev);

            iter_point3_body(math, pFactor, out_s, in0_s, in1_s, in2_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @split_image(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out0 = new_virtual_img(arr.width, arr.height, arr.stride, pipe0);
    let out1 = new_virtual_img(arr.width, arr.height, arr.stride, pipe1);

    let pFactor = get_vector_length();
    let image_size = (arr.height * (arr.stride / pFactor) );
    for benchmark_fpga( get_aocl_sync( out0 ) ) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let in_s   = get_stream(arr_dev);
            let out0_s = set_stream(out0);
            let out1_s = set_stream(out1);

            for idx in range(0, image_size) {
                pragma_pipeline();
                in_s.update(idx);
                for v in unroll(0, pFactor) {
                    let data = in_s.read(v);
                    out0_s.write(v, data);
                    out1_s.write(v, data);
                }
                out0_s.update(idx);
                out1_s.update(idx);
            }
        }
    }
    (out0, out1)
}

// alternative in case of data_pack read/writes (delete in next commit)
// fn @split_image_data_pack(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
//     let acc = accelerator(device_id);
//     let pFactor = get_vector_length();
//     let image_size = (arr.height * (arr.stride / pFactor) );
//     for benchmark_fpga(acc) {
//         for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
//             //for idx in range(0, image_size) {
//             for y in range(0, arr.height) {
//             for x in range(0, arr.stride / pFactor) {
//                 match pFactor {
//                     1 =>  { let din = read_channel(arr.fifo);
//                             write_channel(pipe0, din);
//                             write_channel(pipe1, din); },
//                     2 =>  { let din = read_channel2(arr.fifo);
//                             write_channel2(pipe0, din);
//                             write_channel2(pipe1, din); },
//                     _ => undef()
//                 }
//             }
//             }
//         }
//     }
//     //let out0 = create_virtual_img(arr.width, arr.height, pipe0);
//     //let out1 = create_virtual_img(arr.width, arr.height, pipe1);
//     let out0 = new_virtual_img(arr.width, arr.height, arr.stride, pipe0);
//     let out1 = new_virtual_img(arr.width, arr.height, arr.stride, pipe1);
//     (out0, out1)
// }
