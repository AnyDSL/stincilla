// ---------------------------- streaming --------------------------------------
// global
fn @get_stream_from_global_img(img: Img, pFactor: int) -> stream_in {
    match pFactor {
         1 => get_global_stream_vec1 (img),
         2 => get_global_stream_vec2 (img),
         4 => get_global_stream_vec4 (img),
         8 => get_global_stream_vec8 (img),
        16 => get_global_stream_vec16(img),
        32 => get_global_stream_vec32(img),
         _ => undef[stream_in]()
    }
}

fn @set_stream_from_global_img(img: Img, pFactor: int) -> stream_out {
    match pFactor {
         1 => set_global_stream_vec1 (img),
         2 => set_global_stream_vec2 (img),
         4 => set_global_stream_vec4 (img),
         8 => set_global_stream_vec8 (img),
        16 => set_global_stream_vec16(img),
        32 => set_global_stream_vec32(img),
         _ => undef[stream_out]()
    }
}


fn @get_global_stream_vec1(img: Img) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = bitcast[&[1][pixel_t]](img.buf.data)(idx); }
    fn @read(idx: int) -> pixel_t { value }
    img_to_stream_in(img, 1, update, read)
}

fn @get_global_stream_vec2(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 2, update, read)
}

fn @get_global_stream_vec4(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 4, update, read)
}

fn @get_global_stream_vec8(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 8, update, read)
}

fn @get_global_stream_vec16(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 16, update, read)
}

fn @get_global_stream_vec32(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](img.buf.data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 32, update, read)
}

fn @set_global_stream_vec1(img: Img) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    img_to_stream_out(img, 1, update, write)
}

fn @set_global_stream_vec2(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 2, update, write)
}

fn @set_global_stream_vec4(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 4, update, write)
}

fn @set_global_stream_vec8(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 8, update, write)
}

fn @set_global_stream_vec16(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 16, update, write)
}

fn @set_global_stream_vec32(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](img.buf.data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 32, update, write)
}

// --------------------- accessor: mapping dependent functions ----------------
// images
fn @get_pixel_fn(img: Img) -> fn(i32) -> pixel_t     { @|idx| bitcast[&[1][pixel_t]](img.buf.data)(idx) }
fn @set_pixel_fn(img: Img) -> fn(i32, pixel_t) -> () { @|idx, val| bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = val }

fn @get_device_copy(img: Img) -> Img {
    let acc = accelerator(device_id);
    let img_dev = alloc_img(img, acc.alloc);
    copy_img(img, img_dev);
    img_dev
}

fn @get_host_copy(img_dev: Img, img: Img) -> () {
    let acc = accelerator(device_id);
    acc.sync();
    copy_img(img_dev, img);
}

fn @release_device_copy(img: Img) -> () {
    release(img.buf)
}

//  ------------------- Stencil Processing ----------------------
// coarsening: assumes that image_stride is factor of pFactor
// note that image stride was the factor of 64 at the time this mapping is developed (create_img)
fn @iteration(math: Intrinsics, out: Img, arr: Img, ext: (i32, i32), bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            //let coarsening_fun = FetchAndCalc;
            let coarsening_fun = CalcAndPack;

            let in_s  = get_stream_from_global_img(arr_dev, pFactor);
            let out_s = set_stream_from_global_img(out_dev, pFactor);
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, ext, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

// ------------------------ Point Operators ----------------------------------
fn @iteration_point(math: Intrinsics, out: Img, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
    let acc = accelerator(device_id);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = set_stream_from_global_img(out_dev, pFactor);
            iter_point_body(pFactor, out_s, body);
        }
    }
    get_host_copy(out_dev, out);
}
