// Common
// pipe support
type pipe = channel;

// old
// --------------------- accessor: mapping dependent functions ----------------
// images
//fn @get_pixel_real_fn(img: Img) -> fn(i32) -> pixel_t     { |idx|      bitcast[&[1][pixel_t]](img.buf.data)(idx) }
//fn @set_pixel_real_fn(img: Img) -> fn(i32, pixel_t) -> () { |idx, val| bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = val }
//fn @get_pixel_virtual_fn(img: Img) -> fn(i32) -> pixel_t     { |idx| read_channel(img.fifo) }
//fn @set_pixel_virtual_fn(img: Img) -> fn(i32, pixel_t) -> () { |idx, val| write_channel(img.fifo, val) }
//
//fn @set_pixel_fn(img: Img) -> fn(i32, pixel_t) -> () {
//    if img.virtual == false {
//        set_pixel_real_fn(img)
//    } else {
//        set_pixel_virtual_fn(img)
//    }
//}
//
//fn @get_pixel_fn(img: Img) -> fn(i32) -> pixel_t {
//    if img.virtual == false {
//        get_pixel_real_fn(img)
//    } else {
//        get_pixel_virtual_fn(img)
//    }
//}

// hack
fn @copy_img(src: Img, dst: Img) -> () {
    copy_real_img(src, dst);
}

// new
// --------------------- memory copy functions --------------------------------
fn @copy_real_img(src: Img, dst: Img) -> () {
    if src.virtual == false {
        copy(src.buf, dst.buf, dst.stride * dst.height * sizeof[pixel_t]());
    }
}

fn @get_device_copy(img: Img) -> Img {
    if img.virtual == false {
        let acc = accelerator(device_id);
        let img_dev = alloc_img(img, acc.alloc);
        copy_real_img(img, img_dev);
        img_dev
    } else {
        img
    }
}

fn @get_host_copy(img_dev: Img, img: Img) -> () {
    if img_dev.virtual == false {
        let acc = accelerator(device_id);
        acc.sync();
        copy_real_img(img_dev, img);
    } 
}

fn @release_device_copy(img: Img) -> () {
    if img.virtual == false {
        release(img.buf)
    }
}

// ---------------------------- streaming --------------------------------------
fn @get_stream(img: Img) -> fn() -> stream_in {
    let pFactor = get_vector_length();
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        get_stream_from_global_img(real_img, pFactor)
    } else {
        channel_to_stream_in(img, pFactor)
    }
}

fn @set_stream(img: Img) -> fn() -> stream_out {
    let pFactor = get_vector_length();
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        set_stream_from_global_img(real_img, pFactor)
    } else {
        channel_to_stream_out(img, pFactor)
    }
}

fn @channel_to_stream_in(img: Img, pFactor: int) -> fn() -> stream_in {
    @|| {
        match pFactor {
             1 => channel_to_stream_in_vec1 (img),
             2 => channel_to_stream_in_vec2 (img),
             4 => channel_to_stream_in_vec4 (img),
             8 => channel_to_stream_in_vec8 (img),
            16 => channel_to_stream_in_vec16(img),
            32 => channel_to_stream_in_vec32(img),
             _ => undef[stream_in]()
        }
    }
}

fn @channel_to_stream_out(img: Img, pFactor: int) -> fn() -> stream_out {
    @|| {
        match pFactor {
             1 => channel_to_stream_out_vec1 (img),
             2 => channel_to_stream_out_vec2 (img),
             4 => channel_to_stream_out_vec4 (img),
             8 => channel_to_stream_out_vec8 (img),
            16 => channel_to_stream_out_vec16(img),
            32 => channel_to_stream_out_vec32(img),
             _ => undef[stream_out]()
        }
    }
}

fn @channel_to_stream_out_vec1(img: Img) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { write_channel(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    img_to_stream_out(img, 1, update, write)
}

fn @channel_to_stream_out_vec2(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { write_channel2(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 2, update, write)
}

fn @channel_to_stream_out_vec4(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { write_channel4(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 4, update, write)
}

fn @channel_to_stream_out_vec8(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { write_channel8(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 8, update, write)
}

fn @channel_to_stream_out_vec16(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { write_channel16(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 16, update, write)
}

fn @channel_to_stream_out_vec32(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { write_channel32(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 32, update, write)
}

fn @channel_to_stream_in_vec1(img: Img) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = read_channel(img.fifo); }
    fn @read(idx: int) -> pixel_t { value }
    img_to_stream_in(img, 1, update, read)
}

fn @channel_to_stream_in_vec2(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { value = read_channel2(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 2, update, read)
}

fn @channel_to_stream_in_vec4(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { value = read_channel4(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 4, update, read)
}

fn @channel_to_stream_in_vec8(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { value = read_channel8(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 8, update, read)
}

fn @channel_to_stream_in_vec16(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { value = read_channel16(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 16, update, read)
}

fn @channel_to_stream_in_vec32(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { value = read_channel32(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 32, update, read)
}


// global
fn @get_stream_from_global_img(img: Img, pFactor: int) -> fn() -> stream_in {
    match pFactor {
         1 => get_global_stream_vec1 (img),
         2 => get_global_stream_vec2 (img),
         4 => get_global_stream_vec4 (img),
         8 => get_global_stream_vec8 (img),
        16 => get_global_stream_vec16(img),
        32 => get_global_stream_vec32(img),
         _ => undef[fn() -> stream_in]()
    }
}

fn @set_stream_from_global_img(img: Img, pFactor: int) -> fn() -> stream_out {
    match pFactor {
         1 => set_global_stream_vec1 (img),
         2 => set_global_stream_vec2 (img),
         4 => set_global_stream_vec4 (img),
         8 => set_global_stream_vec8 (img),
        16 => set_global_stream_vec16(img),
        32 => set_global_stream_vec32(img),
         _ => undef[fn() -> stream_out]()
    }
}


fn @get_global_stream_vec1(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][pixel_t]](img.buf.data);
    @|| {
        let mut value = 0 as pixel_t;
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value }
        img_to_stream_in(img, 1, update, read)
    }
}

fn @get_global_stream_vec2(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 2]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 2]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 2 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 2, update, read)
    }
}

fn @get_global_stream_vec4(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 4]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 4]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 4 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 4, update, read)
    }
}

fn @get_global_stream_vec8(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 8]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 8]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 8 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 8, update, read)
    }
}

fn @get_global_stream_vec16(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 16]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 16]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 16 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 16, update, read)
    }
}

fn @get_global_stream_vec32(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 32]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 32]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 32 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 32, update, read)
    }
}

fn @set_global_stream_vec1(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][pixel_t]](img.buf.data);
    @|| {
        let mut value = 0 as pixel_t;
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value = din; }
        img_to_stream_out(img, 1, update, write)
    }
}

fn @set_global_stream_vec2(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 2]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 2]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 2 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 2, update, write)
    }
}

fn @set_global_stream_vec4(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 4]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 4]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 4 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 4, update, write)
    }
}

fn @set_global_stream_vec8(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 8]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 8]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 8 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 8, update, write)
    }
}

fn @set_global_stream_vec16(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 16]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 16]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 16 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 16, update, write)
    }
}

fn @set_global_stream_vec32(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 32]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 32]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 32 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 32, update, write)
    }
}
//  ------------------- Stencil Processing ----------------------
fn @iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(||) {
        let in_s_fn  = get_stream(arr_dev);
        let out_s_fn = set_stream(out_dev);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            //FetchAndCalc, CalcAndPack, FetchAndCalc_nobh, CalcAndPack_nobh
            let coarsening_fun = coarsening_policy;

            let (in_s, out_s) = (in_s_fn(), out_s_fn());
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

//fn @iteration_point(math: Intrinsics, out: Img, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
//    let acc = accelerator(device_id);
//    let out_dev = get_device_copy(out);
//
//    for benchmark_fpga(||) {
//        let out_s_fn = set_stream(out_dev);
//        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
//            let pFactor = get_vector_length();
//            let out_s = out_s_fn();
//            iter_point_body(pFactor, out_s, body);
//        }
//    }
//    get_host_copy(out_dev, out);
//}
fn @iteration_point(math: Intrinsics, out: Img, arr: Img, body: fn(Intrinsics, i32, i32, Acc, pixel_t) -> ()) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga( || ) {
        let out_s_fn = set_stream(out_dev);
        let in_s_fn = get_stream(arr_dev);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();

            let (in_s, out_s) = (in_s_fn(), out_s_fn());
            iter_point_body(math, pFactor, out_s, in_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point2(math: Intrinsics, out: Img, arr0: Img, arr1: Img, body: fn(Intrinsics, i32, i32, Acc, pixel_t, pixel_t) -> ()) -> () {
    let acc = accelerator(device_id);
    let arr0_dev = get_device_copy(arr0);
    let arr1_dev = get_device_copy(arr1);
    let out_dev = get_device_copy(out);

    for benchmark_fpga( || ) {
        let out_s_fn = set_stream(out_dev);
        let in0_s_fn = get_stream(arr0_dev);
        let in1_s_fn = get_stream(arr1_dev);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = out_s_fn();
            let in0_s = in0_s_fn();
            let in1_s = in1_s_fn();
            iter_point2_body(math, pFactor, out_s, in0_s, in1_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point3(math: Intrinsics, out: Img, arr0: Img, arr1: Img, arr2: Img, body: fn(Intrinsics, i32, i32, Acc, pixel_t, pixel_t, pixel_t) -> ()) -> () {
    let acc = accelerator(device_id);
    let arr0_dev = get_device_copy(arr0);
    let arr1_dev = get_device_copy(arr1);
    let arr2_dev = get_device_copy(arr2);
    let out_dev = get_device_copy(out);

    for benchmark_fpga( || ) {
        let out_s_fn = set_stream(out_dev);
        let in0_s_fn = get_stream(arr0_dev);
        let in1_s_fn = get_stream(arr1_dev);
        let in2_s_fn = get_stream(arr2_dev);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = out_s_fn();
            let in0_s = in0_s_fn();
            let in1_s = in1_s_fn();
            let in2_s = in2_s_fn();
            iter_point3_body(math, pFactor, out_s, in0_s, in1_s, in2_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @split_image(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out0 = new_virtual_img(arr.width, arr.height, arr.stride, pipe0);
    let out1 = new_virtual_img(arr.width, arr.height, arr.stride, pipe1);

    let pFactor = get_vector_length();
    let image_size = (arr.height * (arr.stride / pFactor) );
    for benchmark_fpga(||) {
        let   in_s_fn = get_stream(arr_dev);
        let out0_s_fn = set_stream(out0);
        let out1_s_fn = set_stream(out1);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let (in_s, out0_s, out1_s) = (in_s_fn(), out0_s_fn(), out1_s_fn());
            for idx in range(0, image_size) {
                pragma_pipeline();
                in_s.update(idx);
                for v in unroll(0, pFactor) {
                    let data = in_s.read(v);
                    out0_s.write(v, data);
                    out1_s.write(v, data);
                }
                out0_s.update(idx);
                out1_s.update(idx);
            }
        }
    }
    (out0, out1)
}

// alternative in case of data_pack read/writes (delete in next commit)
// fn @split_image_data_pack(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
//     let acc = accelerator(device_id);
//     let pFactor = get_vector_length();
//     let image_size = (arr.height * (arr.stride / pFactor) );
//     for benchmark_fpga(||) {
//         for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
//             //for idx in range(0, image_size) {
//             for y in range(0, arr.height) {
//             for x in range(0, arr.stride / pFactor) {
//                 match pFactor {
//                     1 =>  { let din = read_channel(arr.fifo);
//                             write_channel(pipe0, din);
//                             write_channel(pipe1, din); },
//                     2 =>  { let din = read_channel2(arr.fifo);
//                             write_channel2(pipe0, din);
//                             write_channel2(pipe1, din); },
//                     _ => undef()
//                 }
//             }
//             }
//         }
//     }
//     //let out0 = create_virtual_img(arr.width, arr.height, pipe0);
//     //let out1 = create_virtual_img(arr.width, arr.height, pipe1);
//     let out0 = new_virtual_img(arr.width, arr.height, arr.stride, pipe0);
//     let out1 = new_virtual_img(arr.width, arr.height, arr.stride, pipe1);
//     (out0, out1)
// }
