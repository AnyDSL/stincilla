fn init_zero(arr: &mut[pixel_t], width: i32, height: i32) -> () {
    for i in range(0, width*height) {
        arr(i) = 0 as pixel_t;
    }
}
fn init_rand(arr: &mut[pixel_t], width: i32, height: i32) -> () {
    for y in range(0, height) {
        for x in range(0, width) {
            arr(y*width + x) = (random_val_f32() * 1024f) as pixel_t;
        }
    }
}

fn @min(a: i32, b: i32) -> i32 { if a < b { a } else { b } }
fn @max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }
fn @abs(a: i32) -> i32 { if a < 0 { -a } else { a } }

// nearest multiple of num
fn @round_up(num: i32, multiple: i32) -> i32 { ((num + multiple - 1) / multiple) * multiple }
fn @round_down(num: i32, multiple: i32) -> i32 { (num / multiple) * multiple }

static mut total_cpu_timing = 0i64;
static mut total_gpu_timing = 0i64;
static mut total_fpga_timing = 0i64;
static mut total_host_timing = 0i64;

fn @benchmark(get_time: fn() -> i64, num_iter: i32, body: fn() -> (), sync: fn() -> (), bench_type: &[u8]) -> i64 {
    let times_buf = alloc_cpu(num_iter * sizeof[i64]());
    let times = bitcast[&mut[i64]](times_buf.data);
    for i in range(0, num_iter) {
        let start = get_time();
        body();
        sync();
        times(i) = get_time() - start;
    }
    sort_i64(num_iter, times);
    let median = times(num_iter/2);
    print_string(bench_type);
    print_string(" timing: ");
    print_f64(median as f64 / 1000.0);
    if num_iter > 1 {
        print_string(" | ");
        print_f64(times(0) as f64 / 1000.0);
        print_string(" | ");
        print_f64(times(num_iter-1) as f64 / 1000.0);
        print_string(" (median(");
        print_i32(num_iter);
        print_string(") | minimum | maximum) ms\n");
    } else {
        print_string(" ms\n");
    }
    release(times_buf);
    median
}

static mut num_iter_cpu  = 27;
static mut num_iter_gpu  =  7;
static mut num_iter_fpga =  1;
static     num_iter_host =  5;

fn @benchmark_cpu(                   body: fn() -> ()) -> () { total_cpu_timing  += benchmark(get_micro_time,  num_iter_cpu,  body, ||(), "CPU") }
fn @benchmark_gpu(gpu: Accelerator,  body: fn() -> ()) -> () { total_gpu_timing  += benchmark(get_kernel_time, num_iter_gpu,  body, gpu.sync, "GPU") }
fn @benchmark_fpga(sync: fn() -> (), body: fn() -> ()) -> () { total_fpga_timing += benchmark(get_micro_time,  num_iter_fpga, body, sync, "FPGA") }
fn @benchmark_host(                  body: fn() -> ()) -> () {
    let (num_iter_cpu_old, num_iter_gpu_old, num_iter_fpga_old) = (num_iter_cpu, num_iter_gpu, num_iter_fpga);
    let (total_cpu_timing_old, total_gpu_timing_old, total_fpga_timing_old) = (total_cpu_timing, total_gpu_timing, total_fpga_timing);
    num_iter_cpu = 1; num_iter_gpu = 1; num_iter_fpga = 1;
    total_cpu_timing = 0i64; total_gpu_timing = 0i64; total_fpga_timing = 0i64;
    total_host_timing += benchmark(get_micro_time,  num_iter_host, body, ||(), "End-to-End");
    num_iter_cpu = num_iter_cpu_old; num_iter_gpu = num_iter_gpu_old; num_iter_fpga = num_iter_fpga_old;
    total_cpu_timing = total_cpu_timing_old + total_cpu_timing / num_iter_host as i64;
    total_gpu_timing = total_gpu_timing_old + total_gpu_timing / num_iter_host as i64;
    total_fpga_timing = total_fpga_timing_old + total_fpga_timing / num_iter_host as i64;
}

fn print_total_timing() -> () {
    print_string("Total timing for host / cpu / gpu / fpga: ");
    print_f64(total_host_timing as f64 / 1000.0);
    print_string(" / ");
    print_f64(total_cpu_timing as f64 / 1000.0);
    print_string(" / ");
    print_f64(total_gpu_timing as f64 / 1000.0);
    print_string(" / ");
    print_f64(total_fpga_timing as f64 / 1000.0);
    print_string(" ms\n")
}

fn @(?num) sort_i64(num: i32, arr: &mut[i64]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}
fn @(?num) sort_f32(num: i32, arr: &mut[f32]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}
