// ---------------------------- streaming --------------------------------------
// global
fn @get_stream_from_global_img(img: Img, pFactor: int) -> fn() -> stream_in {
    match pFactor {
         1 => get_global_stream_vec1 (img),
         2 => get_global_stream_vec2 (img),
         4 => get_global_stream_vec4 (img),
         8 => get_global_stream_vec8 (img),
        16 => get_global_stream_vec16(img),
        32 => get_global_stream_vec32(img),
         _ => undef[fn() -> stream_in]()
    }
}

fn @set_stream_from_global_img(img: Img, pFactor: int) -> fn() -> stream_out {
    match pFactor {
         1 => set_global_stream_vec1 (img),
         2 => set_global_stream_vec2 (img),
         4 => set_global_stream_vec4 (img),
         8 => set_global_stream_vec8 (img),
        16 => set_global_stream_vec16(img),
        32 => set_global_stream_vec32(img),
         _ => undef[fn() -> stream_out]()
    }
}


fn @get_global_stream_vec1(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][pixel_t]](img.buf.data);
    @|| {
        let mut value = 0 as pixel_t;
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value }
        img_to_stream_in(img, 1, update, read)
    }
}

fn @get_global_stream_vec2(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 2]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 2]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 2 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 2, update, read)
    }
}

fn @get_global_stream_vec4(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 4]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 4]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 4 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 4, update, read)
    }
}

fn @get_global_stream_vec8(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 8]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 8]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 8 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 8, update, read)
    }
}

fn @get_global_stream_vec16(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 16]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 16]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 16 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 16, update, read)
    }
}

fn @get_global_stream_vec32(img: Img) -> fn() -> stream_in {
    let ptr = bitcast[&[1][[pixel_t * 32]]](
        bitcast[&[1][i8]](
            bitcast[&[1][[pixel_t * 32]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 32 ];
        fn @update(idx: int) -> () { value = ptr(idx); }
        fn @read(idx: int) -> pixel_t { value(idx) }
        img_to_stream_in(img, 32, update, read)
    }
}

fn @set_global_stream_vec1(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][pixel_t]](img.buf.data);
    @|| {
        let mut value = 0 as pixel_t;
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value = din; }
        img_to_stream_out(img, 1, update, write)
    }
}

fn @set_global_stream_vec2(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 2]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 2]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 2 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 2, update, write)
    }
}

fn @set_global_stream_vec4(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 4]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 4]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 4 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 4, update, write)
    }
}

fn @set_global_stream_vec8(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 8]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 8]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 8 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 8, update, write)
    }
}

fn @set_global_stream_vec16(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 16]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 16]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 16 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 16, update, write)
    }
}

fn @set_global_stream_vec32(img: Img) -> fn() -> stream_out {
    let ptr = bitcast[&mut[1][[pixel_t * 32]]](
        bitcast[&mut[1][i8]](
            bitcast[&mut[1][[pixel_t * 32]]](img.buf.data)));
    @|| {
        let mut value = [ 0 as pixel_t, .. 32 ];
        fn @update(idx: int) -> () { ptr(idx) = value; }
        fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
        img_to_stream_out(img, 32, update, write)
    }
}

// --------------------- accessor: mapping dependent functions ----------------
// images
fn @get_pixel_fn(img: Img) -> fn(i32) -> pixel_t     { @|idx| bitcast[&[1][pixel_t]](img.buf.data)(idx) }
fn @set_pixel_fn(img: Img) -> fn(i32, pixel_t) -> () { @|idx, val| bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = val }

fn @get_device_copy(img: Img) -> Img {
    let acc = accelerator(device_id);
    let img_dev = alloc_img(img, acc.alloc);
    copy_img(img, img_dev);
    img_dev
}

fn @get_host_copy(img_dev: Img, img: Img) -> () {
    let acc = accelerator(device_id);
    acc.sync();
    copy_img(img_dev, img);
}

fn @release_device_copy(img: Img) -> () {
    release(img.buf)
}

//  ------------------- Stencil Processing ----------------------
// coarsening: assumes that image_stride is factor of pFactor
// note that image stride was the factor of 64 at the time this mapping is developed (create_img)
fn @iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let pFactor = get_vector_length();

    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);
    for benchmark_fpga(acc) {
        let in_s_fn  = get_stream_from_global_img(arr_dev, pFactor);
        let out_s_fn = set_stream_from_global_img(out_dev, pFactor);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            //let coarsening_fun = FetchAndCalc;
            let coarsening_fun = CalcAndPack;

            let (in_s, out_s) = (in_s_fn(), out_s_fn());
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

// ------------------------ Point Operators ----------------------------------
fn @iteration_point(math: Intrinsics, out: Img, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
    let acc = accelerator(device_id);
    let pFactor = get_vector_length();

    let out_dev = get_device_copy(out);
    for benchmark_fpga(acc) {
        let out_s_fn = set_stream_from_global_img(out_dev, pFactor);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let out_s = out_s_fn();
            iter_point_body(pFactor, out_s, body);
        }
    }
    get_host_copy(out_dev, out);
}
