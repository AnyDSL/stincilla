fn iteration_merge(RHSC: Img, Sol: Img, RHSF: Img,
                   bh_lower: BoundaryFn, bh_upper: BoundaryFn,
                   residual: fn(i32, i32, Acc, Acc, Acc, Mask) -> (), residual_mask: Mask, // RHS + sum(Sol) -> Res
                   restrict: fn(i32, i32, Acc, Acc, Mask) -> (), restrict_mask: Mask       // Res -> RHS(+1)
                  ) -> () {
    let unroll = 1;
    let step   = 2; // restrict by 2x
    let bhy = round_up(residual_mask.size_y / 2, step * unroll);
    let bhx = round_up(residual_mask.size_x / 2, get_vector_length());

    let Bounds2DCol = [
        (0               , bhy),
        (bhy             , Sol.height - bhy),
        (Sol.height - bhy, Sol.height)
    ];

    let Bounds2DRow = [
        (0              , bhx),
        (bhx            , Sol.width - bhx),
        (Sol.width - bhx, Sol.width)
    ];

    for benchmark_cpu() {
        for iter_col in @range(0, 3) {
            let bounds_col = Bounds2DCol(iter_col);
            //let outer_col  = if iter_col == 1 { outer_loop_step } else { range_step };
            // allocate temporary array
            let tmp = alloc_cpu(Sol.stride * step * unroll * sizeof[f32]());
            // gets slower when computed in parallel
            for y in $range_step(bounds_col(0), bounds_col(1), step * unroll) @{
                // residual: index space == cache line
                for iter_row in range(0, 3) {
                    let bounds_row = Bounds2DRow(iter_row);
                    let inner_row  = if iter_row == 1 { inner_loop } else { range };
                    for yi in range(0, step * unroll) {
                        for x in $inner_row(bounds_row(0), bounds_row(1)) @{
                            let region   = Region2D(3 * iter_col + iter_row);
                            let tmp_acc  = get_acc_memory(bitcast[&mut[f32]](tmp.data), Sol.stride, step * unroll);
                            let rhsf_acc = get_acc_offset(RHSF, 0, y);
                            let sol_acc  = get_acc_bh_offset(Sol, 0, y, region, bh_lower, bh_upper);
                            residual(x, yi, tmp_acc, sol_acc, rhsf_acc, residual_mask);
                        }
                    }
                }
                // restrict: index space == cache line
                for yi in range(0, unroll) {
                    let tmp_acc  = get_acc_memory(bitcast[&mut[f32]](tmp.data), Sol.stride, step * unroll);
                    let rhsc_acc = get_acc_offset(RHSC, 0, y/step + yi);
                    for x in $range(0, RHSC.width) @{
                        restrict(x, yi, rhsc_acc, tmp_acc, restrict_mask);
                    }
                }
            }
            release(tmp);
        }
    }
}
