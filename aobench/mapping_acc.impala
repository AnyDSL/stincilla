extern "C" {
    fn mrand48() -> i64;
    fn srand48(i64) -> ();
}

// MWC64X Random Number Generator
// http://cas.ee.ic.ac.uk/people/dt10/research/rngs-gpu-mwc64x.html
fn rnd_u32(state: u64) -> (u32, u64) {
    let hi = state >> 32u64;
    let lo = state & 0xFFFFFFFFu64;
    ((lo as u32) ^ (hi as u32), lo * 4294883355u64 + hi)
}

fn rnd_f64(state: u64) -> (f64, u64) {
    let r = rnd_u32(state);
    let k = 1.0 / (0xFFFFFFFFu64 as f64);
    ((r(0) as f64) * k, r(1))
}

fn iteration(out: Buffer, width: i32, height: i32,
             body: fn(i32, i32, fn(u8, u8, u8) -> (), fn() -> f64) -> ()
            ) -> () {
    let grid  = (width, height, 1);
    let block = (32, 4, 1);

    // initialize seed on the CPU using mrand48()
    srand48(thorin_get_micro_time());
    let seed_buf = alloc_host(width * height * 8);
    let mut seed = seed_buf.data as &[u64];
    for i in $range(0, width * height) {
        seed(i) = mrand48() as u64;
    }

    let seed_gpu = acc_alloc(acc_dev(), width * height * 8);
    let out_gpu  = acc_alloc(acc_dev(), width * height * 3 * 1);
    copy(seed_buf, seed_gpu, width * height * 8);

    for benchmark_acc() {
        with acc(acc_dev(), grid, block) @{
            let seed = seed_gpu.data as &[1][u64];
            let mut state = seed(acc_gidy()*width + acc_gidx());
            fn rand() -> f64 {
                let r = rnd_f64(state);
                state = r(1);
                r(0)
            }
            fn out_fun(r: u8, g: u8, b: u8) -> () {
                let mut out = out_gpu.data as &[1][u8];
                out(3 * (acc_gidy() * width + acc_gidx()) + 0) = r;
                out(3 * (acc_gidy() * width + acc_gidx()) + 1) = g;
                out(3 * (acc_gidy() * width + acc_gidx()) + 2) = b;
            }
            body(acc_gidx(), acc_gidy(), out_fun, rand);
        }
    }

    copy(out_gpu, out, width * height * 3 * 1);
    release(seed_buf);
    release(out_gpu);
}
