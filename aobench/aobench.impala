extern "C" {
    fn saveppm(&[u8], i32, i32) -> ();
}

static WIDTH       = 256;
static HEIGHT      = 256;
static NSUBSAMPLES = 2;
static NAO_SAMPLES = 8;
static PI          = 3.14159265358979323846;

struct vec {
    x: f64,
    y: f64,
    z: f64,
}

struct Isect {
    t: f64,
    p: vec,
    n: vec,
    hit: i32,
}

struct Sphere {
    center: vec,
    radius: f64,
}

struct Plane {
    p: vec,
    n: vec,
}

struct Ray {
    org: vec,
    dir: vec,
}

fn vdot(v0: vec, v1: vec) -> f64 {
    v0.x * v1.x + v0.y * v1.y + v0.z * v1.z
}

fn vcross(v0: vec, v1: vec) -> vec {
    vec { x : v0.y * v1.z - v0.z * v1.y,
          y : v0.z * v1.x - v0.x * v1.z,
          z : v0.x * v1.y - v0.y * v1.x }
}

fn vnormalize(math: Intrinsics, c: vec) -> vec {
    let length = math.sqrt(vdot(c, c));

    if math.fabs(length) > 1.0e-17 {
        return(vec { x : c.x / length, y : c.y / length, z : c.z / length })
    }

    c
}

fn ray_sphere_intersect(math: Intrinsics, isect: Isect, ray: Ray, sphere: Sphere) -> Isect {
    let rs = vec {
        x : ray.org.x - sphere.center.x,
        y : ray.org.y - sphere.center.y,
        z : ray.org.z - sphere.center.z
    };

    let B = vdot(rs, ray.dir);
    let C = vdot(rs, rs) - sphere.radius * sphere.radius;
    let D = B * B - C;

    if D > 0.0 {
        let t = -B - math.sqrt(D);

        if t > 0.0 && t < isect.t {
            let p = vec { x : ray.org.x + ray.dir.x * t,
                          y : ray.org.y + ray.dir.y * t,
                          z : ray.org.z + ray.dir.z * t };
            let n = vec { x : p.x - sphere.center.x,
                          y : p.y - sphere.center.y,
                          z : p.z - sphere.center.z };
            let isect = Isect { t : t, p : p, n: vnormalize(math, n), hit : 1 };
            return(isect)
        }
    }

    isect
}

fn ray_plane_intersect(math: Intrinsics, isect: Isect, ray: Ray, plane: Plane) -> Isect {
    let d = -vdot(plane.p, plane.n);
    let v =  vdot(ray.dir, plane.n);

    if math.fabs(v) >= 1.0e-17 @{
        let t = -(vdot(ray.org, plane.n) + d) / v;

        if t > 0.0 && t < isect.t {
            let p = vec { x : ray.org.x + ray.dir.x * t,
                          y : ray.org.y + ray.dir.y * t,
                          z : ray.org.z + ray.dir.z * t };
            let isect = Isect { t : t, p : p, n: plane.n, hit : 1 };
            return(isect)
        }
    }

    isect
}

fn ortho_basis(math: Intrinsics, n: vec) -> [vec * 3] {
    let mut basis: [vec * 3];
    let mut x = 0.0; let mut y = 0.0; let mut z = 0.0;

    if n.x < 0.6 && n.x > -0.6 {
        x = 1.0;
    } else if n.y < 0.6 && n.y > -0.6 {
        y = 1.0;
    } else if n.z < 0.6 && n.z > -0.6 {
        z = 1.0;
    } else {
        x = 1.0;
    }

    basis(1).x = x; basis(1).y = y; basis(1).z = z;
    basis(2) = n;
    basis(0) = vnormalize(math, vcross(basis(1), basis(2)));
    basis(1) = vnormalize(math, vcross(basis(2), basis(0)));

    basis
}

fn ambient_occlusion(math: Intrinsics, isect: Isect, spheres: [Sphere * 3], plane: Plane, rand: fn() -> f64) -> f64 {
    let ntheta = NAO_SAMPLES;
    let nphi   = NAO_SAMPLES;
    let eps    = 0.0001;

    let p = vec {
        x : isect.p.x + eps * isect.n.x,
        y : isect.p.y + eps * isect.n.y,
        z : isect.p.z + eps * isect.n.z
    };

    let basis = ortho_basis(math, isect.n);

    let mut occlusion = 0.0;

    for j in $range(0, ntheta) @{
        for i in range(0, nphi) {
            let theta = math.sqrt(rand());
            let phi   = 2.0 * PI * rand();

            let x = math.cos(phi) * theta;
            let y = math.sin(phi) * theta;
            let z = math.sqrt(1.0 - theta * theta);

            // local -> global
            let rx = x * basis(0).x + y * basis(1).x + z * basis(2).x;
            let ry = x * basis(0).y + y * basis(1).y + z * basis(2).y;
            let rz = x * basis(0).z + y * basis(1).z + z * basis(2).z;

            let ray = Ray {
                org : p,
                dir : vec { x : rx, y : ry, z : rz }
            };

            let mut occ_isect: Isect;
            occ_isect.t   = 1.0e+17;
            occ_isect.hit = 0;

            occ_isect = ray_sphere_intersect(math, occ_isect, ray, spheres(0));
            occ_isect = ray_sphere_intersect(math, occ_isect, ray, spheres(1));
            occ_isect = ray_sphere_intersect(math, occ_isect, ray, spheres(2));
            occ_isect = ray_plane_intersect (math, occ_isect, ray, plane);

            if occ_isect.hit == 1 { occlusion += 1.0; }
        }
    }

    occlusion = ((ntheta * nphi) as f64 - occlusion) / (ntheta * nphi) as f64;

    occlusion
}

fn clamp(f: f64) -> u8 {
    let mut i = (f*255.5) as i32;

    if i < 0   { i = 0; }
    if i > 255 { i = 255; }

    i as u8
}

fn render(img: Buffer, w: int, h: int, nsubsamples: int, spheres: [Sphere * 3], plane: Plane) -> () {
    for math, x, y, out, rand in @iteration(math, img, w, h) {
        let mut r = 0.0;
        let mut g = 0.0;
        let mut b = 0.0;
        for v in $range(0, nsubsamples) {
            for u in range(0, nsubsamples) @{
                let px =  (x as f64 + u as f64 / nsubsamples as f64 - w as f64 / 2.0) / (w as f64 / 2.0);
                let py = -(y as f64 + v as f64 / nsubsamples as f64 - h as f64 / 2.0) / (h as f64 / 2.0);

                let ray = Ray {
                    org :                  vec { x : 0.0, y : 0.0, z :  0.0 },
                    dir : vnormalize(math, vec { x : px,  y : py,  z : -1.0 })
                };

                let mut isect: Isect;
                isect.t   = 1.0e+17;
                isect.hit = 0;

                isect = ray_sphere_intersect(math, isect, ray, spheres(0));
                isect = ray_sphere_intersect(math, isect, ray, spheres(1));
                isect = ray_sphere_intersect(math, isect, ray, spheres(2));
                isect = ray_plane_intersect (math, isect, ray, plane);

                if isect.hit == 1 @{
                    let col = ambient_occlusion(math, isect, spheres, plane, rand);

                    r += col;
                    g += col;
                    b += col;
                }
            }
        }

        r /= (nsubsamples * nsubsamples) as f64;
        g /= (nsubsamples * nsubsamples) as f64;
        b /= (nsubsamples * nsubsamples) as f64;

        out(clamp(r), clamp(g), clamp(b))
    }
}

fn init_scene() -> ([Sphere * 3], Plane) {
    let spheres = [ Sphere { center : vec { x : -2.0, y : 0.0, z : -3.5 }, radius : 0.5 },
                    Sphere { center : vec { x : -0.5, y : 0.0, z : -3.0 }, radius : 0.5 },
                    Sphere { center : vec { x :  1.0, y : 0.0, z : -2.2 }, radius : 0.5 } ];

    let plane = Plane { p : vec { x : 0.0, y : -0.5, z : 0.0 },
                        n : vec { x : 0.0, y :  1.0, z : 0.0 } };

    (spheres, plane)
}

extern
fn aobench() -> () {
    let img = alloc_cpu(WIDTH*HEIGHT*3 * sizeof[u8]());
    let (spheres, plane) = init_scene();
    render(img, WIDTH, HEIGHT, NSUBSAMPLES, spheres, plane);
    saveppm(bitcast[&[u8]](img.data), WIDTH, HEIGHT);
    release(img);
    print_total_timing()
}
